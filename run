#!/usr/bin/env python3

import multiprocessing
import os
import sys
import threading
import time

import PIL.Image
import PIL.ImageChops


assert multiprocessing.get_start_method() == 'fork'

if __name__ == '__main__':
    images_path = sys.argv[1]
    captures_path = sys.argv[2]
    dosbox_configuration = sys.argv[3]
    test_command = sys.argv[4:]

    assert captures_path.startswith('/tmp')
    os.makedirs(captures_path, exist_ok=True)
    for name in os.listdir(captures_path):
        os.remove(os.path.join(captures_path, name))

    env = os.environ.copy()
    env['SDL_AUDIODRIVER'] = ''

    output_in, output_out = os.pipe()
    input_in, input_out = os.pipe()
    process = multiprocessing.Process(target=lambda: (
        os.close(input_out),
        os.dup2(input_in, 0),
        os.close(input_in),
        os.close(output_in),
        os.dup2(output_out, 1),
        os.close(output_out),
        os.execlpe('stdbuf', 'stdbuf', '-oL', 'dosbox', '-conf', dosbox_configuration, *test_command, env),
    ))

    process.start()
    os.close(input_in)
    os.close(output_out)

    screenshot_ready = threading.Event()

    # FIXME separate library

    def output_thread():
        with os.fdopen(output_in) as output_file:
            while data := output_file.readline():
                data = data.strip()
                if data == 'SCREENSHOT':
                    screenshot_ready.set()

    def subtract_timeout(timeout, seconds):
        if timeout is None:
            return None
        elif timeout < seconds:
            raise TimeoutError()
        else:
            return timeout - seconds

    def get_screenshot(timeout=None):
        print('SCREENSHOT', file=input_file, flush=True)
        if not screenshot_ready.wait(timeout=timeout):
            raise TimeoutError()
        screenshot_ready.clear()
        name, = os.listdir(captures_path)
        return os.path.join(captures_path, name)

    def quit():
        print('BYE', file=input_file, flush=True)

    def wait_image(expected_path, max_diff_area=0, timeout=None):
        expected = PIL.Image.open(expected_path)
        t = None
        while True:
            if t is not None:
                timeout = subtract_timeout(timeout, time.monotonic() - t)
            t = time.monotonic()

            path = get_screenshot(timeout=timeout)

            actual = PIL.Image.open(path)
            os.remove(path)
            diff = PIL.ImageChops.difference(actual, expected).getbbox()
            if diff is None or (diff[2]-diff[0])*(diff[3]-diff[1]) <= max_diff_area:
                return

    def send_keys(keys):
        for key in keys:
            code = ord(key.lower())
            modifiers = 0
            if key == '▴':
                code = 273
            elif key == '▾':
                code = 274
            elif key == '▸':
                code = 275
            elif key == '◂':
                code = 276
            elif key.isupper():
                modifiers = 1
                print('KEY DOWN 304 0', file=input_file, flush=True)
            print(f'KEY DOWN {code} {modifiers}', file=input_file, flush=True)
            print(f'KEY UP {code} {modifiers}', file=input_file, flush=True)
            if modifiers == 1:
                print('KEY UP 304 0', file=input_file, flush=True)

    thread = threading.Thread(target=output_thread)
    thread.start()

    with os.fdopen(input_out, 'w') as input_file:
        try:
            time.sleep(1.5) # FIXME DOSBox fails to save screenshots when its loading

            wait_image(os.path.join(images_path, 'graphics.png'), timeout=1)
            send_keys('C\r') # CGA mode.

            wait_image(os.path.join(images_path, 'input.png'), timeout=1)
            send_keys('K\r') # Input from keyboard.

            wait_image(os.path.join(images_path, 'door.png'), timeout=5)
            send_keys('\r') # Enter door.

            wait_image(os.path.join(images_path, 'lobby.png'), timeout=1)
            send_keys('\r') # Enter elevator.

            wait_image(os.path.join(images_path, 'menu.png'), timeout=5)
            send_keys('TEST\r') # Enter player name.

            time.sleep(0.05)
            send_keys('\r') # Select single player mode.

            wait_image(os.path.join(images_path, 'elevator.png'), timeout=1)
            send_keys('1A') # Go to first floor.

            wait_image(os.path.join(images_path, 'level.png'), timeout=2)
            # TODO make auto solver
            # TODO there is more optimal route for level 1
            for i, keys in enumerate((
                '▴◂◂◂▴▴▴◂ ▴ ◂◂▾ ◂◂▾▾▾▸ ▸ ▸ ▸ ▸ ▸ ▸ ▸ ▸ ▸ ▸ ▸ ▸ ▾▸▴ ◂◂',
                '◂◂◂◂◂◂◂◂◂◂◂◂▴◂◂▾▸ ▸ ▸ ▸ ▸ ▸ ▸ ▸ ▸ ▸ ▸ ▸ ▸ ▸ ▴▸▾ ◂▾▸ ▴◂',
                '◂◂◂◂◂◂◂▴▴▴◂▴◂◂▾▾ ▾ ▴▴◂◂▾▾▾▸▸ ▸ ▸ ▸ ▸ ▸ ▸ ▸ ▸ ▸ ▸ ▸ ◂',
                '◂◂◂◂◂◂◂▴▴▴◂◂ ▴◂▾ ▾ ▾ ▴▴◂◂▾▾▾▸▸ ▸ ▸ ▸ ▸ ▸ ▸ ▸ ▸ ▸ ▸ ▾▸▴ ◂',
                '◂◂◂◂◂◂◂▴▴▴◂◂▴▴▴◂▾ ▾ ▾ ▾ ▾ ▴▴◂◂▾▾▾▸▸ ▸ ▸ ▸ ▸ ▸ ▸ ▸ ▸ ▸ ▴▸▾ ◂▾▸ ▴',
                '◂◂◂◂◂◂◂▴▴▴◂◂▴▴▴▸▾ ▾ ◂◂▾▾▾▾▸▸▸▴▴▴◂ ◂ ▴◂▾ ▾ ▾ ▴▴◂◂▾▾▾▸▸ ▸ ▸ ▸ ▸ ▸ ▸ ▸ ▸ ▸ ▸',
            )):
                for key in keys:
                    if key != ' ':
                        send_keys(key)
                        time.sleep(0.25)
                    else:
                        time.sleep(0.2)

                if i < 5:
                    step = ('one', 'two', 'three', 'four', 'five')[i]
                    wait_image(os.path.join(images_path, f'step-{step}.png'), max_diff_area=450, timeout=1)

            wait_image(os.path.join(images_path, 'win.png'), timeout=10)

        finally:
            quit()

    process.join()
    thread.join()
